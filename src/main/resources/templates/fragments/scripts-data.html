<th:block th:fragment="scripts-data">
<script th:inline="javascript">
    const timestamps = /*[[${view.chartTimestamps}]]*/[];
    const labels = /*[[${view.chartLabels}]]*/[];
    const latencyData = /*[[${view.chartLatencies}]]*/[];
    const latencyMinData = /*[[${view.chartLatencyMins}]]*/[];
    const latencyMaxData = /*[[${view.chartLatencyMaxs}]]*/[];
    const errorRateData = /*[[${view.chartErrorRates}]]*/[];
    const wsErrorRateData = /*[[${view.chartWsErrorRates}]]*/[];
    const httpErrorBuckets = /*[[${view.chartHttpErrors}]]*/[];
    const wsErrorBuckets = /*[[${view.chartWsErrors}]]*/[];
    const httpErrorOngoing = /*[[${view.httpErrorOngoing}]]*/ false;
    const wsErrorOngoing = /*[[${view.wsErrorOngoing}]]*/ false;
    const headDelayData = /*[[${view.chartHeadDelays}]]*/[];
    const headDelayMinData = /*[[${view.chartHeadDelayMins}]]*/[];
    const headDelayMaxData = /*[[${view.chartHeadDelayMaxs}]]*/[];
    const safeDelayData = /*[[${view.chartSafeDelays}]]*/[];
    const safeDelayMinData = /*[[${view.chartSafeDelayMins}]]*/[];
    const safeDelayMaxData = /*[[${view.chartSafeDelayMaxs}]]*/[];
    const finalizedDelayData = /*[[${view.chartFinalizedDelays}]]*/[];
    const finalizedDelayMinData = /*[[${view.chartFinalizedDelayMins}]]*/[];
    const finalizedDelayMaxData = /*[[${view.chartFinalizedDelayMaxs}]]*/[];
    const referenceHeadDelayData = /*[[${view.chartReferenceHeadDelays}]]*/[];
    const referenceSafeDelayData = /*[[${view.chartReferenceSafeDelays}]]*/[];
    const referenceFinalizedDelayData = /*[[${view.chartReferenceFinalizedDelays}]]*/[];
    const hasAggregatedLatencies = /*[[${view.hasAggregatedLatencies}]]*/ false;
    const hasAggregatedDelays = /*[[${view.hasAggregatedDelays}]]*/ false;
    const wsConfigured = /*[[${view.wsConfigured}]]*/ false;
    const safeBlocksEnabled = /*[[${view.safeBlocksEnabled}]]*/ false;
    const isReferenceNode = /*[[${view.referenceNode}]]*/ false;
    const multiNodeConfigured = /*[[${view.multiNodeConfigured}]]*/ false;
    const samples = /*[[${view.sampleRows}]]*/[];
    const anomalies = /*[[${view.anomalyRows}]]*/[];
    const pageSize = /*[[${view.pageSize}]]*/ 50;
    const totalPages = /*[[${view.totalPages}]]*/ 1;
    const anomalyPageSize = /*[[${view.anomalyPageSize}]]*/ 50;
    const anomalyTotalPages = /*[[${view.anomalyTotalPages}]]*/ 1;
    const scaleChangeMs = /*[[${view.scaleChangeMs}]]*/ 500;
    const scaleMaxMs = /*[[${view.scaleMaxMs}]]*/ 30000;
    const hasOlderAggregates = /*[[${view.hasOlderAggregates}]]*/ false;
    const rangeKey = /*[[${range.key}]]*/ null;
    const viewEndEpochMs = /*[[${endEpochMs}]]*/ null;
    const hasHeadDelaySeries = headDelayData.some(value => value != null) || referenceHeadDelayData.some(value => value != null);
    const hasSafeDelaySeries = safeDelayData.some(value => value != null) || referenceSafeDelayData.some(value => value != null);
    const hasFinalizedDelaySeries = finalizedDelayData.some(value => value != null) || referenceFinalizedDelayData.some(value => value != null);
    const delayChartsAvailable = wsConfigured
        || hasHeadDelaySeries
        || hasSafeDelaySeries
        || hasFinalizedDelaySeries;

    const cssVars = getComputedStyle(document.documentElement);
    const getVar = (name, fallback) => {
        const value = cssVars.getPropertyValue(name).trim();
        return value || fallback;
    };
    const theme = {
        primary: getVar('--color-primary', '#5b8dff'),
        primaryRgb: getVar('--color-primary-rgb', '91, 141, 255'),
        headDelay: getVar('--color-head-delay', getVar('--color-warning', '#f4b740')),
        headDelayRgb: getVar('--color-head-delay-rgb', getVar('--color-warning-rgb', '244, 183, 64')),
        safeDelay: getVar('--color-safe-delay', getVar('--color-warning', '#f4b740')),
        safeDelayRgb: getVar('--color-safe-delay-rgb', getVar('--color-warning-rgb', '244, 183, 64')),
        success: getVar('--color-success', '#2ec77e'),
        successRgb: getVar('--color-success-rgb', '46, 199, 126'),
        danger: getVar('--color-danger', '#ff6b6b'),
        dangerRgb: getVar('--color-danger-rgb', '255, 107, 107'),
        purple: getVar('--color-purple', '#b074ff'),
        purpleRgb: getVar('--color-purple-rgb', '176, 116, 255'),
        text: getVar('--color-text', '#e6e8ee'),
        textSubtle: getVar('--color-text-subtle', '#8b93a7'),
        grid: getVar('--color-border', '#20263a')
    };

    const referenceToggle = document.getElementById('toggleReferenceLines');
    const boundsToggle = document.getElementById('toggleBounds');
    let showReferences = referenceToggle ? referenceToggle.checked : false;
    let showBounds = boundsToggle ? boundsToggle.checked : false;
    const referenceAvailable = !isReferenceNode
        && (referenceHeadDelayData.length > 0 || referenceSafeDelayData.length > 0 || referenceFinalizedDelayData.length > 0);
    const referenceToggleLabel = document.getElementById('referenceToggleLabel');
    if (referenceToggleLabel && !referenceAvailable) {
        referenceToggleLabel.style.display = 'none';
        showReferences = false;
        if (referenceToggle) {
            referenceToggle.checked = false;
        }
    }
    const rawMaxDelayValue = Math.max(
        0,
        ...latencyData.filter(value => value != null),
        ...latencyMaxData.filter(value => value != null),
        ...headDelayData.filter(value => value != null),
        ...headDelayMaxData.filter(value => value != null),
        ...safeDelayData.filter(value => value != null),
        ...safeDelayMaxData.filter(value => value != null),
        ...finalizedDelayData.filter(value => value != null),
        ...finalizedDelayMaxData.filter(value => value != null),
        ...(referenceAvailable && showReferences ? referenceHeadDelayData.filter(value => value != null) : []),
        ...(referenceAvailable && showReferences ? referenceSafeDelayData.filter(value => value != null) : []),
        ...(referenceAvailable && showReferences ? referenceFinalizedDelayData.filter(value => value != null) : [])
    );
    const maxDelayValue = Math.min(scaleMaxMs, rawMaxDelayValue);
    const scaledAxisMax = 1000;
    const lowBandRatio = 0.2;
    const lowBandMax = scaleChangeMs;
    const lowBandSize = scaledAxisMax * lowBandRatio;

    const scaleValue = (value) => {
        if (value == null) {
            return null;
        }
        if (maxDelayValue <= lowBandMax) {
            return value;
        }
        if (value <= lowBandMax) {
            return (value / lowBandMax) * lowBandSize;
        }
        return lowBandSize + ((value - lowBandMax) / (maxDelayValue - lowBandMax)) * (scaledAxisMax - lowBandSize);
    };

    const createDiagonalPattern = (color, direction) => {
        const size = 8;
        const lineWidth = 2;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const patternCtx = canvas.getContext('2d');
        if (!patternCtx) {
            return color;
        }
        patternCtx.strokeStyle = color;
        patternCtx.lineWidth = lineWidth;
        patternCtx.beginPath();
        if (direction === 'up') {
            patternCtx.moveTo(0, size);
            patternCtx.lineTo(size, 0);
        } else {
            patternCtx.moveTo(0, 0);
            patternCtx.lineTo(size, size);
        }
        patternCtx.stroke();
        return patternCtx.createPattern(canvas, 'repeat');
    };

    const httpPattern = createDiagonalPattern(`rgba(${theme.dangerRgb}, 0.35)`, 'down');
    const wsPattern = createDiagonalPattern(`rgba(${theme.purpleRgb}, 0.35)`, 'up');

    const confidenceBandPlugin = {
        id: 'confidenceBands',
        beforeDatasetsDraw(chart) {
            const { ctx, chartArea, scales } = chart;
            const xScale = scales.x;
            const yScale = scales.y;
            if (!chartArea || !xScale || !yScale) {
                return;
            }

            const minWidthPx = 5;
            const getStepWidth = (index) => {
                if (index < labels.length - 1) {
                    return xScale.getPixelForValue(index + 1) - xScale.getPixelForValue(index);
                }
                if (index > 0) {
                    return xScale.getPixelForValue(index) - xScale.getPixelForValue(index - 1);
                }
                return minWidthPx;
            };

            const drawBand = (minSeries, maxSeries, baseColor) => {
                if (!minSeries || !maxSeries) {
                    return;
                }
                for (let i = 0; i < labels.length; i += 1) {
                    const minValue = minSeries[i];
                    const maxValue = maxSeries[i];
                    if (minValue == null || maxValue == null) {
                        continue;
                    }
                    const width = Math.max(minWidthPx, getStepWidth(i));
                    const xStart = xScale.getPixelForValue(i) - width / 2;
                    const yMin = yScale.getPixelForValue(minValue);
                    const yMax = yScale.getPixelForValue(maxValue);
                    const top = Math.min(yMin, yMax);
                    const height = Math.abs(yMin - yMax);

                    ctx.fillStyle = baseColor;
                    ctx.fillRect(xStart, top, width, height);
                }
            };

            if (!showBounds) {
                return;
            }
            ctx.save();
            if (hasAggregatedLatencies) {
                drawBand(latencyMinScaled, latencyMaxScaled, `rgba(${theme.primaryRgb}, 0.12)`);
            }
            if (delayChartsAvailable && hasAggregatedDelays) {
                drawBand(headDelayMinScaled, headDelayMaxScaled, `rgba(${theme.headDelayRgb}, 0.12)`);
                if (safeBlocksEnabled) {
                    drawBand(safeDelayMinScaled, safeDelayMaxScaled, `rgba(${theme.safeDelayRgb}, 0.08)`);
                }
                drawBand(finalizedDelayMinScaled, finalizedDelayMaxScaled, `rgba(${theme.successRgb}, 0.12)`);
            }
            ctx.restore();
        }
    };

    const inverseScale = (value) => {
        if (maxDelayValue <= lowBandMax) {
            return value;
        }
        if (value <= lowBandSize) {
            return Math.round((value / lowBandSize) * lowBandMax);
        }
        return Math.round(lowBandMax + ((value - lowBandSize) / (scaledAxisMax - lowBandSize)) * (maxDelayValue - lowBandMax));
    };

    // Helper function to scale multiple data arrays
    const scaleMultiple = (arrays) => arrays.map(arr => arr.map(scaleValue));

    // Color gradient function for latency values (blue < 200ms -> purple < 500ms -> red > 500ms)
    const getLatencyColor = (latencyMs, alpha = 1) => {
        if (latencyMs == null) return null;
        
        let r, g, b;
        if (latencyMs < 200) {
            // Blue (91, 141, 255) at 0ms, transitioning to purple at 200ms
            const t = latencyMs / 200;
            r = Math.round(91 + (176 - 91) * t);    // 91 -> 176
            g = Math.round(141 + (116 - 141) * t);  // 141 -> 116
            b = Math.round(255 + (255 - 255) * t);  // 255 -> 255
        } else if (latencyMs < 500) {
            // Purple (176, 116, 255) at 200ms, transitioning to red at 500ms
            const t = (latencyMs - 200) / 300;
            r = Math.round(176 + (255 - 176) * t);  // 176 -> 255
            g = Math.round(116 + (107 - 116) * t);  // 116 -> 107
            b = Math.round(255 + (107 - 255) * t);  // 255 -> 107
        } else {
            // Red (255, 107, 107) for 500ms and above
            r = 255;
            g = 107;
            b = 107;
        }
        
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const getLatencyGradientColors = (dataArray) => {
        if (!dataArray || dataArray.length === 0) return [];
        
        const colors = [];
        for (let i = 0; i < dataArray.length; i++) {
            const value = dataArray[i];
            if (value != null) {
                const unscaled = inverseScale(value);
                colors.push(getLatencyColor(unscaled, 0.8));
            } else {
                colors.push(null);
            }
        }
        return colors;
    };

    const [
        latencyScaled, latencyMinScaled, latencyMaxScaled,
        headDelayScaled, headDelayMinScaled, headDelayMaxScaled,
        safeDelayScaled, safeDelayMinScaled, safeDelayMaxScaled,
        finalizedDelayScaled, finalizedDelayMinScaled, finalizedDelayMaxScaled,
        referenceHeadDelayScaled, referenceSafeDelayScaled, referenceFinalizedDelayScaled
    ] = scaleMultiple([
        latencyData, latencyMinData, latencyMaxData,
        headDelayData, headDelayMinData, headDelayMaxData,
        safeDelayData, safeDelayMinData, safeDelayMaxData,
        finalizedDelayData, finalizedDelayMinData, finalizedDelayMaxData,
        referenceHeadDelayData, referenceSafeDelayData, referenceFinalizedDelayData
    ]);

    // After the legend is drawn, replace the rectangle swatches for "Network Latency" and
    // "Head Delay P95" with short horizontal lines that mirror the actual chart lines.
    // The generateLabels callback hides the default boxes for these two items (transparent
    // fill + no border) so this plugin draws cleanly on the cleared swatch area.
    // Chart.js populates legendHitBoxes during draw(); each entry has {left, top, width, height}.
    const LEGEND_LINE_ITEMS = new Set(['Network Latency', 'Head Delay P95']);
    const latencyLegendGradientPlugin = {
        id: 'latencyLegendGradient',
        afterDraw(chart) {
            const legend = chart.legend;
            if (!legend || !legend.legendItems || !legend.legendHitBoxes) return;
            const boxWidth = (legend.options.labels && legend.options.labels.boxWidth) || 40;
            legend.legendItems.forEach((item, i) => {
                if (!LEGEND_LINE_ITEMS.has(item.text)) return;
                const box = legend.legendHitBoxes[i];
                if (!box) return;
                const x0 = box.left;
                const x1 = x0 + boxWidth;
                const y  = box.top + box.height / 2;
                const chartCtx = chart.ctx;

                let strokeStyle;
                if (item.text === 'Network Latency') {
                    // Full blue → purple → red gradient, accurate to the same breakpoints used
                    // by the chart line's per-segment colouring.
                    const grad = chartCtx.createLinearGradient(x0, 0, x1, 0);
                    grad.addColorStop(0,         getLatencyColor(0,   1.0));  // blue   @ 0 ms
                    grad.addColorStop(200 / 500, getLatencyColor(200, 1.0));  // purple @ 200 ms
                    grad.addColorStop(1.0,       getLatencyColor(500, 1.0));  // red    @ 500 ms
                    strokeStyle = grad;
                } else {
                    // Head Delay P95 → solid line in the theme head-delay colour
                    strokeStyle = theme.headDelay;
                }

                chartCtx.save();
                chartCtx.strokeStyle = strokeStyle;
                chartCtx.lineWidth   = 3; // slightly thicker than the 2 px chart lines
                chartCtx.lineCap     = 'round';
                chartCtx.setLineDash([]);
                chartCtx.beginPath();
                chartCtx.moveTo(x0, y);
                chartCtx.lineTo(x1, y);
                chartCtx.stroke();
                chartCtx.restore();
            });
        }
    };

    const createLineDataset = ({
        label,
        data,
        originalData,
        color,
        rgb,
        backgroundAlpha,
        order,
        useLatencyGradient
    }) => {
        const dataset = {
            label,
            data,
            originalData,
            borderColor: color,
            backgroundColor: `rgba(${rgb}, ${backgroundAlpha})`,
            spanGaps: true,
            tension: 0.2,
            yAxisID: 'y',
            order,
            borderWidth: 2
        };

        if (useLatencyGradient && originalData) {
            // Chart.js segment context provides p0DataIndex / p1DataIndex (start and end of each
            // rendered segment) and p0 / p1 (PointElement with pixel x/y coordinates).
            // We create a horizontal canvas LinearGradient for each segment so the color
            // transitions smoothly from the value at p0 to the value at p1.
            dataset.segment = {
                borderColor: ctx => {
                    const v0 = originalData[ctx.p0DataIndex];
                    const v1 = originalData[ctx.p1DataIndex];
                    // Both null → spanning a full gap, keep line invisible (spanGaps still draws it)
                    if (v0 == null && v1 == null) return color;
                    // One side null (leading/trailing gap): use the available value
                    const eff0 = v0 ?? v1;
                    const eff1 = v1 ?? v0;
                    const c0 = getLatencyColor(eff0, 1.0);
                    const c1 = getLatencyColor(eff1, 1.0);
                    // Same color zone — skip gradient allocation
                    if (c0 === c1) return c0;
                    // Horizontal gradient (along the time axis) so the colour at each x
                    // accurately reflects the latency at that data point.
                    const gradient = ctx.chart.ctx.createLinearGradient(ctx.p0.x, 0, ctx.p1.x, 0);
                    gradient.addColorStop(0, c0);
                    gradient.addColorStop(1, c1);
                    return gradient;
                }
            };
        }

        return dataset;
    };

    const createBandDataset = ({ label, data, originalData, rgb }) => ({
        label,
        data,
        originalData,
        borderColor: `rgba(${rgb}, 0.45)`,
        backgroundColor: `rgba(${rgb}, 0.0)`,
        spanGaps: true,
        tension: 0.2,
        yAxisID: 'y',
        pointRadius: 0,
        borderWidth: 1,
        bandLine: true,
        hidden: !showBounds,
        order: 1
    });

    const createReferenceDataset = ({ label, data, originalData, color, rgb }) => ({
        label,
        data,
        originalData,
        borderColor: color,
        backgroundColor: `rgba(${rgb}, 0.0)`,
        borderDash: [6, 6],
        hidden: !showReferences,
        spanGaps: true,
        tension: 0.2,
        yAxisID: 'y',
        referenceLine: true
    });
</script>
</th:block>

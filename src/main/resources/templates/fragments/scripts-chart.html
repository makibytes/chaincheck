<th:block th:fragment="scripts-chart">
<script>
    const ctx = document.getElementById('latencyChart');
    if (ctx) {
        const datasets = [createLineDataset({
            label: 'Network Latency',
            data: latencyScaled,
            originalData: latencyData,
            color: theme.primary,
            rgb: theme.primaryRgb,
            backgroundAlpha: 0.2,
            order: 2
        })];

        if (hasAggregatedLatencies) {
            datasets.push(createBandDataset({
                label: 'Network Latency (Low)',
                data: latencyMinScaled,
                originalData: latencyMinData,
                rgb: theme.primaryRgb
            }));

            datasets.push(createBandDataset({
                label: 'Network Latency (High)',
                data: latencyMaxScaled,
                originalData: latencyMaxData,
                rgb: theme.primaryRgb
            }));
        }

        const errorBarPlugin = {
            id: 'errorBars',
            beforeDatasetsDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                const xScale = scales.x;
                if (!chartArea || !xScale || !timestamps || timestamps.length === 0) {
                    return;
                }

                const minWidthPx = 5;
                const height = chartArea.bottom - chartArea.top;

                const getStepWidth = (index) => {
                    if (index < timestamps.length - 1) {
                        return xScale.getPixelForValue(index + 1) - xScale.getPixelForValue(index);
                    }
                    if (index > 0) {
                        return xScale.getPixelForValue(index) - xScale.getPixelForValue(index - 1);
                    }
                    return minWidthPx;
                };

                const buildErrorMask = (series) => {
                    const length = series.length;
                    const prevNonNullError = new Array(length).fill(false);
                    const nextNonNullError = new Array(length).fill(false);

                    let lastNonNullError = null;
                    for (let i = 0; i < length; i += 1) {
                        const value = series[i];
                        if (value != null) {
                            lastNonNullError = value > 0;
                        }
                        prevNonNullError[i] = lastNonNullError === true;
                    }

                    let nextError = null;
                    for (let i = length - 1; i >= 0; i -= 1) {
                        const value = series[i];
                        if (value != null) {
                            nextError = value > 0;
                        }
                        nextNonNullError[i] = nextError === true;
                    }

                    return series.map((value, index) => {
                        if (value != null) {
                            return value > 0;
                        }
                        return prevNonNullError[index] && nextNonNullError[index];
                    });
                };

                const drawBars = (series, pattern, ongoing) => {
                    const errorMask = buildErrorMask(series);
                    
                    const hasAnyError = errorMask.some(e => e);
                    if (!hasAnyError) {
                        return;
                    }
                    
                    if (ongoing) {
                        let lastErrorIndex = -1;
                        for (let i = errorMask.length - 1; i >= 0; i -= 1) {
                            if (errorMask[i]) {
                                lastErrorIndex = i;
                                break;
                            }
                        }
                        if (lastErrorIndex >= 0) {
                            for (let i = lastErrorIndex; i < errorMask.length; i += 1) {
                                errorMask[i] = true;
                            }
                        }
                    }
                    let startIndex = null;
                    for (let i = 0; i <= errorMask.length; i += 1) {
                        const hasError = i < errorMask.length && errorMask[i];
                        if (hasError && startIndex === null) {
                            startIndex = i;
                        }
                        if (startIndex !== null && (!hasError || i === errorMask.length)) {
                            const endIndex = i - 1;
                            const xStart = xScale.getPixelForValue(startIndex);
                            const xEnd = xScale.getPixelForValue(endIndex) + getStepWidth(endIndex);
                            const width = Math.max(minWidthPx, xEnd - xStart);
                            ctx.fillStyle = pattern;
                            ctx.fillRect(xStart, chartArea.top, width, height);
                            startIndex = null;
                        }
                    }
                };

                ctx.save();
                drawBars(errorRateData, httpPattern, httpErrorOngoing);
                if (wsConfigured) {
                    drawBars(wsErrorRateData, wsPattern, wsErrorOngoing);
                }
                ctx.restore();
            }
        };

        const scaleIndicatorPlugin = {
            id: 'scaleIndicator',
            afterDatasetsDraw(chart) {
                if (maxDelayValue <= lowBandMax) {
                    return;
                }
                const { ctx, chartArea, scales } = chart;
                const yScale = scales.y;
                if (!chartArea || !yScale) {
                    return;
                }
                const boundaryValue = lowBandSize;
                const y = yScale.getPixelForValue(boundaryValue);
                const lineColor = `rgba(${theme.primaryRgb}, 0.4)`;
                const labelColor = theme.text;
                const badgeBg = `rgba(${theme.primaryRgb}, 0.16)`;

                ctx.save();
                ctx.setLineDash([6, 6]);
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = lineColor;
                ctx.beginPath();
                ctx.moveTo(chartArea.left, y);
                ctx.lineTo(chartArea.right, y);
                ctx.stroke();

                const label = `Scale change @ ${lowBandMax} ms`;
                ctx.font = '12px "Inter", "Segoe UI", system-ui, sans-serif';
                const textWidth = ctx.measureText(label).width;
                const paddingX = 8;
                const paddingY = 4;
                const badgeWidth = textWidth + paddingX * 2;
                const badgeHeight = 20;
                const badgeX = chartArea.right - badgeWidth - 8;
                const badgeY = Math.max(chartArea.top + 6, y - badgeHeight - 6);

                ctx.setLineDash([]);
                ctx.fillStyle = badgeBg;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, 6);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = labelColor;
                ctx.textBaseline = 'middle';
                ctx.fillText(label, badgeX + paddingX, badgeY + badgeHeight / 2);
                ctx.restore();
            }
        };

        // Helper function to add delay datasets
        function addDelayDatasets(datasets, config) {
            const {
                type,
                color,
                rgb,
                data,
                minData,
                maxData,
                refData,
                originalData,
                originalMinData,
                originalMaxData,
                referenceOriginalData,
                pointRadius = 0,
                pointHoverRadius = 3
            } = config;

            datasets.push(createLineDataset({
                label: `${type} Delay`,
                data: data,
                originalData: originalData,
                color: color,
                rgb: rgb,
                backgroundAlpha: 0.2,
                order: 2
            }));

            const lineDataset = datasets[datasets.length - 1];
            lineDataset.borderDash = [];
            lineDataset.pointRadius = pointRadius;
            lineDataset.pointHoverRadius = pointHoverRadius;

            if (hasAggregatedDelays) {
                datasets.push(createBandDataset({
                    label: `${type} Delay (Low)`,
                    data: minData,
                    originalData: originalMinData,
                    rgb: rgb
                }));

                datasets.push(createBandDataset({
                    label: `${type} Delay (High)`,
                    data: maxData,
                    originalData: originalMaxData,
                    rgb: rgb
                }));
            }

            if (referenceAvailable) {
                datasets.push(createReferenceDataset({
                    label: `${type} Delay (Reference)`,
                    data: refData,
                    originalData: referenceOriginalData,
                    color: color,
                    rgb: rgb
                }));
            }
        }

        if (delayChartsAvailable) {
            if (hasHeadDelaySeries) {
                addDelayDatasets(datasets, {
                    type: 'Head',
                    color: theme.headDelay,
                    rgb: theme.headDelayRgb,
                    data: headDelayScaled,
                    minData: headDelayMinScaled,
                    maxData: headDelayMaxScaled,
                    refData: referenceHeadDelayScaled,
                    originalData: headDelayData,
                    originalMinData: headDelayMinData,
                    originalMaxData: headDelayMaxData,
                    referenceOriginalData: referenceHeadDelayData
                });
            }

            if (hasSafeDelaySeries) {
                addDelayDatasets(datasets, {
                    type: 'Safe',
                    color: theme.safeDelay,
                    rgb: theme.safeDelayRgb,
                    data: safeDelayScaled,
                    minData: safeDelayMinScaled,
                    maxData: safeDelayMaxScaled,
                    refData: referenceSafeDelayScaled,
                    originalData: safeDelayData,
                    originalMinData: safeDelayMinData,
                    originalMaxData: safeDelayMaxData,
                    referenceOriginalData: referenceSafeDelayData,
                    pointRadius: 2,
                    pointHoverRadius: 4
                });
            }

            if (hasFinalizedDelaySeries) {
                addDelayDatasets(datasets, {
                    type: 'Finalized',
                    color: theme.success,
                    rgb: theme.successRgb,
                    data: finalizedDelayScaled,
                    minData: finalizedDelayMinScaled,
                    maxData: finalizedDelayMaxScaled,
                    refData: referenceFinalizedDelayScaled,
                    originalData: finalizedDelayData,
                    originalMinData: finalizedDelayMinData,
                    originalMaxData: finalizedDelayMaxData,
                    referenceOriginalData: referenceFinalizedDelayData
                });
            }
        }

        datasets.push({
            label: 'HTTP Errors',
            data: labels.map(() => null),
            borderColor: `rgba(${theme.dangerRgb}, 0.25)`,
            backgroundColor: `rgba(${theme.dangerRgb}, 0.25)`,
            pointRadius: 0,
            borderWidth: 0,
            showLine: false
        });

        if (wsConfigured) {
            datasets.push({
                label: 'WS Errors',
                data: labels.map(() => null),
                borderColor: `rgba(${theme.purpleRgb}, 0.25)`,
                backgroundColor: `rgba(${theme.purpleRgb}, 0.25)`,
                pointRadius: 0,
                borderWidth: 0,
                showLine: false
            });
        }

        const chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets
            },
            plugins: [confidenceBandPlugin, errorBarPlugin, scaleIndicatorPlugin],
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: theme.text,
                            generateLabels: (chart) => {
                                const baseLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart)
                                    .filter((legendItem) => {
                                        const dataset = chart.data.datasets[legendItem.datasetIndex];
                                        return !dataset.referenceLine && !dataset.bandLine;
                                    });

                                baseLabels.forEach((legendItem) => {
                                    if (legendItem.text === 'HTTP Errors') {
                                        legendItem.fillStyle = httpPattern;
                                        legendItem.strokeStyle = 'rgba(0, 0, 0, 0)';
                                    }
                                    if (legendItem.text === 'WS Errors') {
                                        legendItem.fillStyle = wsPattern;
                                        legendItem.strokeStyle = 'rgba(0, 0, 0, 0)';
                                    }
                                });

                                if (referenceAvailable && showReferences) {
                                    baseLabels.push({
                                        text: 'Reference Node',
                                        fillStyle: 'rgba(0, 0, 0, 0)',
                                        strokeStyle: theme.textSubtle,
                                        lineWidth: 2,
                                        lineDash: [6, 6],
                                        hidden: false
                                    });
                                }

                                return baseLabels;
                            }
                        }
                    },
                    tooltip: {
                        filter: (context) => !context.dataset.bandLine,
                        callbacks: {
                            label: (context) => {
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                if (dataset && Array.isArray(dataset.originalData)) {
                                    const value = dataset.originalData[dataIndex];
                                    if (value == null) {
                                        return `${dataset.label}: n/a`;
                                    }
                                    return `${dataset.label}: ${value} ms`;
                                }
                                return `${context.dataset.label}: ${context.formattedValue}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        ticks: {
                            color: theme.textSubtle,
                            display: true,
                            maxRotation: 45,
                            minRotation: 0
                        },
                        grid: { color: theme.grid }
                    },
                    y: {
                        min: 0,
                        max: maxDelayValue <= lowBandMax ? undefined : scaledAxisMax,
                        ticks: {
                            color: theme.textSubtle,
                            callback: (value) => `${inverseScale(value)} ms`
                        },
                        grid: { color: theme.grid }
                    }
                }
            }
        });

        if (referenceToggle) {
            referenceToggle.addEventListener('change', (event) => {
                showReferences = event.target.checked;
                chartInstance.data.datasets.forEach((dataset) => {
                    if (dataset.referenceLine) {
                        dataset.hidden = !showReferences;
                    }
                });
                chartInstance.update();
            });
        }

        if (boundsToggle) {
            boundsToggle.addEventListener('change', (event) => {
                showBounds = event.target.checked;
                chartInstance.data.datasets.forEach((dataset) => {
                    if (dataset.bandLine) {
                        dataset.hidden = !showBounds;
                    }
                });
                chartInstance.update();
            });
        }
    }
</script>
</th:block>

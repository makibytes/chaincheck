<th:block th:fragment="scripts">
<script th:inline="javascript">
    const timestamps = /*[[${view.chartTimestamps}]]*/[];
    const labels = /*[[${view.chartLabels}]]*/[];
    const latencyData = /*[[${view.chartLatencies}]]*/[];
    const latencyMinData = /*[[${view.chartLatencyMins}]]*/[];
    const latencyMaxData = /*[[${view.chartLatencyMaxs}]]*/[];
    const errorRateData = /*[[${view.chartErrorRates}]]*/[];
    const wsErrorRateData = /*[[${view.chartWsErrorRates}]]*/[];
    const httpErrorBuckets = /*[[${view.chartHttpErrors}]]*/[];
    const wsErrorBuckets = /*[[${view.chartWsErrors}]]*/[];
    const headDelayData = /*[[${view.chartHeadDelays}]]*/[];
    const headDelayMinData = /*[[${view.chartHeadDelayMins}]]*/[];
    const headDelayMaxData = /*[[${view.chartHeadDelayMaxs}]]*/[];
    const safeDelayData = /*[[${view.chartSafeDelays}]]*/[];
    const safeDelayMinData = /*[[${view.chartSafeDelayMins}]]*/[];
    const safeDelayMaxData = /*[[${view.chartSafeDelayMaxs}]]*/[];
    const finalizedDelayData = /*[[${view.chartFinalizedDelays}]]*/[];
    const finalizedDelayMinData = /*[[${view.chartFinalizedDelayMins}]]*/[];
    const finalizedDelayMaxData = /*[[${view.chartFinalizedDelayMaxs}]]*/[];
    const referenceHeadDelayData = /*[[${view.chartReferenceHeadDelays}]]*/[];
    const referenceSafeDelayData = /*[[${view.chartReferenceSafeDelays}]]*/[];
    const referenceFinalizedDelayData = /*[[${view.chartReferenceFinalizedDelays}]]*/[];
    const hasAggregatedLatencies = /*[[${view.hasAggregatedLatencies}]]*/ false;
    const hasAggregatedDelays = /*[[${view.hasAggregatedDelays}]]*/ false;
    const wsConfigured = /*[[${view.wsConfigured}]]*/ false;
    const safeBlocksEnabled = /*[[${view.safeBlocksEnabled}]]*/ false;
    const isReferenceNode = /*[[${view.referenceNode}]]*/ false;
    const samples = /*[[${view.sampleRows}]]*/[];
    const anomalies = /*[[${view.anomalyRows}]]*/[];
    const pageSize = /*[[${view.pageSize}]]*/ 50;
    const totalPages = /*[[${view.totalPages}]]*/ 1;
    const anomalyPageSize = /*[[${view.anomalyPageSize}]]*/ 50;
    const anomalyTotalPages = /*[[${view.anomalyTotalPages}]]*/ 1;
    const scaleChangeMs = /*[[${view.scaleChangeMs}]]*/ 500;

    const cssVars = getComputedStyle(document.documentElement);
    const getVar = (name, fallback) => {
        const value = cssVars.getPropertyValue(name).trim();
        return value || fallback;
    };
    const theme = {
        primary: getVar('--color-primary', '#5b8dff'),
        primaryRgb: getVar('--color-primary-rgb', '91, 141, 255'),
        warning: getVar('--color-warning', '#f4b740'),
        warningRgb: getVar('--color-warning-rgb', '244, 183, 64'),
        headDelay: getVar('--color-head-delay', getVar('--color-warning', '#f4b740')),
        headDelayRgb: getVar('--color-head-delay-rgb', getVar('--color-warning-rgb', '244, 183, 64')),
        safeDelay: getVar('--color-safe-delay', getVar('--color-warning', '#f4b740')),
        safeDelayRgb: getVar('--color-safe-delay-rgb', getVar('--color-warning-rgb', '244, 183, 64')),
        success: getVar('--color-success', '#2ec77e'),
        successRgb: getVar('--color-success-rgb', '46, 199, 126'),
        danger: getVar('--color-danger', '#ff6b6b'),
        dangerRgb: getVar('--color-danger-rgb', '255, 107, 107'),
        purple: getVar('--color-purple', '#b074ff'),
        purpleRgb: getVar('--color-purple-rgb', '176, 116, 255'),
        text: getVar('--color-text', '#e6e8ee'),
        textSubtle: getVar('--color-text-subtle', '#8b93a7'),
        grid: getVar('--color-border', '#20263a')
    };

    const referenceToggle = document.getElementById('toggleReferenceLines');
    const boundsToggle = document.getElementById('toggleBounds');
    let showReferences = referenceToggle ? referenceToggle.checked : false;
    let showBounds = boundsToggle ? boundsToggle.checked : false;
    const referenceAvailable = !isReferenceNode
        && (referenceHeadDelayData.length > 0 || referenceSafeDelayData.length > 0 || referenceFinalizedDelayData.length > 0);
    const referenceToggleLabel = document.getElementById('referenceToggleLabel');
    if (referenceToggleLabel && !referenceAvailable) {
        referenceToggleLabel.style.display = 'none';
        showReferences = false;
        if (referenceToggle) {
            referenceToggle.checked = false;
        }
    }
    const maxDelayValue = Math.max(
        0,
        ...latencyData.filter(value => value != null),
        ...latencyMaxData.filter(value => value != null),
        ...headDelayData.filter(value => value != null),
        ...headDelayMaxData.filter(value => value != null),
        ...safeDelayData.filter(value => value != null),
        ...safeDelayMaxData.filter(value => value != null),
        ...finalizedDelayData.filter(value => value != null),
        ...finalizedDelayMaxData.filter(value => value != null),
        ...(referenceAvailable && showReferences ? referenceHeadDelayData.filter(value => value != null) : []),
        ...(referenceAvailable && showReferences ? referenceSafeDelayData.filter(value => value != null) : []),
        ...(referenceAvailable && showReferences ? referenceFinalizedDelayData.filter(value => value != null) : [])
    );
    const scaledAxisMax = 1000;
    const lowBandRatio = 0.2;
    const lowBandMax = scaleChangeMs;
    const lowBandSize = scaledAxisMax * lowBandRatio;

    const scaleValue = (value) => {
        if (value == null) {
            return null;
        }
        if (maxDelayValue <= lowBandMax) {
            return value;
        }
        if (value <= lowBandMax) {
            return (value / lowBandMax) * lowBandSize;
        }
        return lowBandSize + ((value - lowBandMax) / (maxDelayValue - lowBandMax)) * (scaledAxisMax - lowBandSize);
    };

        const createDiagonalPattern = (color, direction) => {
            const size = 8;
            const lineWidth = 2;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const patternCtx = canvas.getContext('2d');
            if (!patternCtx) {
                return color;
            }
            patternCtx.strokeStyle = color;
            patternCtx.lineWidth = lineWidth;
            patternCtx.beginPath();
            if (direction === 'up') {
                patternCtx.moveTo(0, size);
                patternCtx.lineTo(size, 0);
            } else {
                patternCtx.moveTo(0, 0);
                patternCtx.lineTo(size, size);
            }
            patternCtx.stroke();
            return patternCtx.createPattern(canvas, 'repeat');
        };

        const httpPattern = createDiagonalPattern(`rgba(${theme.dangerRgb}, 0.35)`, 'down');
        const wsPattern = createDiagonalPattern(`rgba(${theme.purpleRgb}, 0.35)`, 'up');

        const confidenceBandPlugin = {
            id: 'confidenceBands',
            beforeDatasetsDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                const xScale = scales.x;
                const yScale = scales.y;
                if (!chartArea || !xScale || !yScale) {
                    return;
                }

                const minWidthPx = 5;
                const getStepWidth = (index) => {
                    if (index < labels.length - 1) {
                        return xScale.getPixelForValue(index + 1) - xScale.getPixelForValue(index);
                    }
                    if (index > 0) {
                        return xScale.getPixelForValue(index) - xScale.getPixelForValue(index - 1);
                    }
                    return minWidthPx;
                };

                const drawBand = (minSeries, maxSeries, baseColor) => {
                    if (!minSeries || !maxSeries) {
                        return;
                    }
                    for (let i = 0; i < labels.length; i += 1) {
                        const minValue = minSeries[i];
                        const maxValue = maxSeries[i];
                        if (minValue == null || maxValue == null) {
                            continue;
                        }
                        const width = Math.max(minWidthPx, getStepWidth(i));
                        const xStart = xScale.getPixelForValue(i) - width / 2;
                        const yMin = yScale.getPixelForValue(minValue);
                        const yMax = yScale.getPixelForValue(maxValue);
                        const top = Math.min(yMin, yMax);
                        const height = Math.abs(yMin - yMax);

                        ctx.fillStyle = baseColor;
                        ctx.fillRect(xStart, top, width, height);

                        if (httpErrorBuckets[i]) {
                            ctx.fillStyle = httpPattern;
                            ctx.fillRect(xStart, top, width, height);
                        }
                        if (wsErrorBuckets[i]) {
                            ctx.fillStyle = wsPattern;
                            ctx.fillRect(xStart, top, width, height);
                        }
                    }
                };

                if (!showBounds) {
                    return;
                }
                ctx.save();
                if (hasAggregatedLatencies) {
                    drawBand(latencyMinScaled, latencyMaxScaled, `rgba(${theme.primaryRgb}, 0.12)`);
                }
                if (wsConfigured && hasAggregatedDelays) {
                    drawBand(headDelayMinScaled, headDelayMaxScaled, `rgba(${theme.headDelayRgb}, 0.12)`);
                    if (safeBlocksEnabled) {
                        drawBand(safeDelayMinScaled, safeDelayMaxScaled, `rgba(${theme.safeDelayRgb}, 0.08)`);
                    }
                    drawBand(finalizedDelayMinScaled, finalizedDelayMaxScaled, `rgba(${theme.successRgb}, 0.12)`);
                }
                ctx.restore();
            }
        };

    const inverseScale = (value) => {
        if (maxDelayValue <= lowBandMax) {
            return value;
        }
        if (value <= lowBandSize) {
            return Math.round((value / lowBandSize) * lowBandMax);
        }
        return Math.round(lowBandMax + ((value - lowBandSize) / (scaledAxisMax - lowBandSize)) * (maxDelayValue - lowBandMax));
    };

    const latencyScaled = latencyData.map(scaleValue);
    const latencyMinScaled = latencyMinData.map(scaleValue);
    const latencyMaxScaled = latencyMaxData.map(scaleValue);
    const headDelayScaled = headDelayData.map(scaleValue);
    const headDelayMinScaled = headDelayMinData.map(scaleValue);
    const headDelayMaxScaled = headDelayMaxData.map(scaleValue);
    const safeDelayScaled = safeDelayData.map(scaleValue);
    const safeDelayMinScaled = safeDelayMinData.map(scaleValue);
    const safeDelayMaxScaled = safeDelayMaxData.map(scaleValue);
    const finalizedDelayScaled = finalizedDelayData.map(scaleValue);
    const finalizedDelayMinScaled = finalizedDelayMinData.map(scaleValue);
    const finalizedDelayMaxScaled = finalizedDelayMaxData.map(scaleValue);
    const referenceHeadDelayScaled = referenceHeadDelayData.map(scaleValue);
    const referenceSafeDelayScaled = referenceSafeDelayData.map(scaleValue);
    const referenceFinalizedDelayScaled = referenceFinalizedDelayData.map(scaleValue);

    const ctx = document.getElementById('latencyChart');
    if (ctx) {
        const datasets = [{
            label: 'Network Latency',
            data: latencyScaled,
            originalData: latencyData,
            borderColor: theme.primary,
            backgroundColor: `rgba(${theme.primaryRgb}, 0.2)`,
            spanGaps: true,
            tension: 0.2,
            yAxisID: 'y',
            order: 2
        }];

        if (hasAggregatedLatencies) {
            datasets.push({
                label: 'Network Latency (Low)',
                data: latencyMinScaled,
                originalData: latencyMinData,
                borderColor: `rgba(${theme.primaryRgb}, 0.45)`,
                backgroundColor: `rgba(${theme.primaryRgb}, 0.0)`,
                spanGaps: true,
                tension: 0.2,
                yAxisID: 'y',
                pointRadius: 0,
                borderWidth: 1,
                bandLine: true,
                hidden: !showBounds,
                order: 1
            });

            datasets.push({
                label: 'Network Latency (High)',
                data: latencyMaxScaled,
                originalData: latencyMaxData,
                borderColor: `rgba(${theme.primaryRgb}, 0.45)`,
                backgroundColor: `rgba(${theme.primaryRgb}, 0.0)`,
                spanGaps: true,
                tension: 0.2,
                yAxisID: 'y',
                pointRadius: 0,
                borderWidth: 1,
                bandLine: true,
                hidden: !showBounds,
                order: 1
            });
        }

        const errorBarPlugin = {
            id: 'errorBars',
            beforeDatasetsDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                const xScale = scales.x;
                if (!chartArea || !xScale || !timestamps || timestamps.length === 0) {
                    return;
                }

                const minWidthPx = 5;
                const height = chartArea.bottom - chartArea.top;

                const getStepWidth = (index) => {
                    if (index < timestamps.length - 1) {
                        return xScale.getPixelForValue(index + 1) - xScale.getPixelForValue(index);
                    }
                    if (index > 0) {
                        return xScale.getPixelForValue(index) - xScale.getPixelForValue(index - 1);
                    }
                    return minWidthPx;
                };

                const buildErrorMask = (series) => {
                    const length = series.length;
                    const prevNonNullError = new Array(length).fill(false);
                    const nextNonNullError = new Array(length).fill(false);

                    let lastNonNullError = null;
                    for (let i = 0; i < length; i += 1) {
                        const value = series[i];
                        if (value != null) {
                            lastNonNullError = value > 0;
                        }
                        prevNonNullError[i] = lastNonNullError === true;
                    }

                    let nextError = null;
                    for (let i = length - 1; i >= 0; i -= 1) {
                        const value = series[i];
                        if (value != null) {
                            nextError = value > 0;
                        }
                        nextNonNullError[i] = nextError === true;
                    }

                    return series.map((value, index) => {
                        if (value != null) {
                            return value > 0;
                        }
                        return prevNonNullError[index] && nextNonNullError[index];
                    });
                };

                const drawBars = (series, pattern) => {
                    const errorMask = buildErrorMask(series);
                    let startIndex = null;
                    for (let i = 0; i <= errorMask.length; i += 1) {
                        const hasError = i < errorMask.length && errorMask[i];
                        if (hasError && startIndex === null) {
                            startIndex = i;
                        }
                        if (startIndex !== null && (!hasError || i === errorMask.length)) {
                            const endIndex = i - 1;
                            const xStart = xScale.getPixelForValue(startIndex);
                            const xEnd = xScale.getPixelForValue(endIndex) + getStepWidth(endIndex);
                            const width = Math.max(minWidthPx, xEnd - xStart);
                            ctx.fillStyle = pattern;
                            ctx.fillRect(xStart, chartArea.top, width, height);
                            startIndex = null;
                        }
                    }
                };

                ctx.save();
                drawBars(errorRateData, httpPattern);
                if (wsConfigured) {
                    drawBars(wsErrorRateData, wsPattern);
                }
                ctx.restore();
            }
        };

        const scaleIndicatorPlugin = {
            id: 'scaleIndicator',
            afterDatasetsDraw(chart) {
                if (maxDelayValue <= lowBandMax) {
                    return;
                }
                const { ctx, chartArea, scales } = chart;
                const yScale = scales.y;
                if (!chartArea || !yScale) {
                    return;
                }
                const boundaryValue = lowBandSize;
                const y = yScale.getPixelForValue(boundaryValue);
                const lineColor = `rgba(${theme.primaryRgb}, 0.4)`;
                const labelColor = theme.text;
                const badgeBg = `rgba(${theme.primaryRgb}, 0.16)`;

                ctx.save();
                ctx.setLineDash([6, 6]);
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = lineColor;
                ctx.beginPath();
                ctx.moveTo(chartArea.left, y);
                ctx.lineTo(chartArea.right, y);
                ctx.stroke();

                const label = `Scale change @ ${lowBandMax} ms`;
                ctx.font = '12px "Inter", "Segoe UI", system-ui, sans-serif';
                const textWidth = ctx.measureText(label).width;
                const paddingX = 8;
                const paddingY = 4;
                const badgeWidth = textWidth + paddingX * 2;
                const badgeHeight = 20;
                const badgeX = chartArea.right - badgeWidth - 8;
                const badgeY = Math.max(chartArea.top + 6, y - badgeHeight - 6);

                ctx.setLineDash([]);
                ctx.fillStyle = badgeBg;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, 6);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = labelColor;
                ctx.textBaseline = 'middle';
                ctx.fillText(label, badgeX + paddingX, badgeY + badgeHeight / 2);
                ctx.restore();
            }
        };

        if (wsConfigured) {
            datasets.push({
                label: 'Head Delay',
                data: headDelayScaled,
                originalData: headDelayData,
                borderColor: theme.headDelay,
                backgroundColor: `rgba(${theme.headDelayRgb}, 0.2)`,
                spanGaps: true,
                tension: 0.2,
                yAxisID: 'y',
                order: 2
            });

            if (hasAggregatedDelays) {
                datasets.push({
                    label: 'Head Delay (Low)',
                    data: headDelayMinScaled,
                    originalData: headDelayMinData,
                    borderColor: `rgba(${theme.headDelayRgb}, 0.45)`,
                    backgroundColor: `rgba(${theme.headDelayRgb}, 0.0)`,
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y',
                    pointRadius: 0,
                    borderWidth: 1,
                    bandLine: true,
                    hidden: !showBounds,
                    order: 1
                });

                datasets.push({
                    label: 'Head Delay (High)',
                    data: headDelayMaxScaled,
                    originalData: headDelayMaxData,
                    borderColor: `rgba(${theme.headDelayRgb}, 0.45)`,
                    backgroundColor: `rgba(${theme.headDelayRgb}, 0.0)`,
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y',
                    pointRadius: 0,
                    borderWidth: 1,
                    bandLine: true,
                    hidden: !showBounds,
                    order: 1
                });
            }

                if (referenceAvailable) {
                    datasets.push({
                        label: 'Head Delay (Reference)',
                        data: referenceHeadDelayScaled,
                        originalData: referenceHeadDelayData,
                        borderColor: theme.headDelay,
                            backgroundColor: `rgba(${theme.headDelayRgb}, 0.0)`,
                        borderDash: [6, 6],
                        hidden: !showReferences,
                        spanGaps: true,
                        tension: 0.2,
                        yAxisID: 'y',
                        referenceLine: true
                    });
                }

            if (safeBlocksEnabled) {
                datasets.push({
                    label: 'Safe Delay',
                    data: safeDelayScaled,
                    originalData: safeDelayData,
                borderColor: theme.safeDelay,
                backgroundColor: `rgba(${theme.safeDelayRgb}, 0.18)`,
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y',
                    order: 2
                });

                if (hasAggregatedDelays) {
                    datasets.push({
                        label: 'Safe Delay (Low)',
                        data: safeDelayMinScaled,
                        originalData: safeDelayMinData,
                        borderColor: `rgba(${theme.safeDelayRgb}, 0.45)`,
                        backgroundColor: `rgba(${theme.safeDelayRgb}, 0.0)`,
                        spanGaps: true,
                        tension: 0.2,
                        yAxisID: 'y',
                        pointRadius: 0,
                        borderWidth: 1,
                        bandLine: true,
                        hidden: !showBounds,
                        order: 1
                    });

                    datasets.push({
                        label: 'Safe Delay (High)',
                        data: safeDelayMaxScaled,
                        originalData: safeDelayMaxData,
                        borderColor: `rgba(${theme.safeDelayRgb}, 0.45)`,
                        backgroundColor: `rgba(${theme.safeDelayRgb}, 0.0)`,
                        spanGaps: true,
                        tension: 0.2,
                        yAxisID: 'y',
                        pointRadius: 0,
                        borderWidth: 1,
                        bandLine: true,
                        hidden: !showBounds,
                        order: 1
                    });
                }

                    if (referenceAvailable) {
                        datasets.push({
                            label: 'Safe Delay (Reference)',
                            data: referenceSafeDelayScaled,
                            originalData: referenceSafeDelayData,
                        borderColor: theme.safeDelay,
                            backgroundColor: `rgba(${theme.safeDelayRgb}, 0.0)`,
                            borderDash: [6, 6],
                            hidden: !showReferences,
                            spanGaps: true,
                            tension: 0.2,
                            yAxisID: 'y',
                            referenceLine: true
                        });
                    }
            }

            datasets.push({
                label: 'Finalized Delay',
                data: finalizedDelayScaled,
                originalData: finalizedDelayData,
            borderColor: theme.success,
            backgroundColor: `rgba(${theme.successRgb}, 0.2)`,
                spanGaps: true,
                tension: 0.2,
                yAxisID: 'y',
                order: 2
            });

            if (hasAggregatedDelays) {
                datasets.push({
                    label: 'Finalized Delay (Low)',
                    data: finalizedDelayMinScaled,
                    originalData: finalizedDelayMinData,
                    borderColor: `rgba(${theme.successRgb}, 0.45)`,
                    backgroundColor: `rgba(${theme.successRgb}, 0.0)`,
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y',
                    pointRadius: 0,
                    borderWidth: 1,
                    bandLine: true,
                    hidden: !showBounds,
                    order: 1
                });

                datasets.push({
                    label: 'Finalized Delay (High)',
                    data: finalizedDelayMaxScaled,
                    originalData: finalizedDelayMaxData,
                    borderColor: `rgba(${theme.successRgb}, 0.45)`,
                    backgroundColor: `rgba(${theme.successRgb}, 0.0)`,
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y',
                    pointRadius: 0,
                    borderWidth: 1,
                    bandLine: true,
                    hidden: !showBounds,
                    order: 1
                });
            }

                if (referenceAvailable) {
                    datasets.push({
                        label: 'Finalized Delay (Reference)',
                        data: referenceFinalizedDelayScaled,
                        originalData: referenceFinalizedDelayData,
                    borderColor: theme.success,
                        backgroundColor: `rgba(${theme.successRgb}, 0.0)`,
                        borderDash: [6, 6],
                        hidden: !showReferences,
                        spanGaps: true,
                        tension: 0.2,
                        yAxisID: 'y',
                        referenceLine: true
                    });
                }
        }

        datasets.push({
            label: 'HTTP Errors',
            data: labels.map(() => null),
            borderColor: `rgba(${theme.dangerRgb}, 0.25)`,
            backgroundColor: `rgba(${theme.dangerRgb}, 0.25)`,
            pointRadius: 0,
            borderWidth: 0,
            showLine: false
        });

        if (wsConfigured) {
            datasets.push({
                label: 'WS Errors',
                data: labels.map(() => null),
                borderColor: `rgba(${theme.purpleRgb}, 0.25)`,
                backgroundColor: `rgba(${theme.purpleRgb}, 0.25)`,
                pointRadius: 0,
                borderWidth: 0,
                showLine: false
            });
        }

        const chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets
            },
            plugins: [confidenceBandPlugin, errorBarPlugin, scaleIndicatorPlugin],
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: theme.text,
                            generateLabels: (chart) => {
                                const baseLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart)
                                    .filter((legendItem) => {
                                        const dataset = chart.data.datasets[legendItem.datasetIndex];
                                        return !dataset.referenceLine && !dataset.bandLine;
                                    });

                                baseLabels.forEach((legendItem) => {
                                    if (legendItem.text === 'HTTP Errors') {
                                        legendItem.fillStyle = httpPattern;
                                        legendItem.strokeStyle = 'rgba(0, 0, 0, 0)';
                                    }
                                    if (legendItem.text === 'WS Errors') {
                                        legendItem.fillStyle = wsPattern;
                                        legendItem.strokeStyle = 'rgba(0, 0, 0, 0)';
                                    }
                                });

                                if (referenceAvailable && showReferences) {
                                    baseLabels.push({
                                        text: 'Reference Node',
                                        fillStyle: 'rgba(0, 0, 0, 0)',
                                        strokeStyle: theme.textSubtle,
                                        lineWidth: 2,
                                        lineDash: [6, 6],
                                        hidden: false
                                    });
                                }

                                return baseLabels;
                            }
                        }
                    },
                    tooltip: {
                        filter: (context) => !context.dataset.bandLine,
                        callbacks: {
                            label: (context) => {
                                const dataset = context.dataset;
                                const dataIndex = context.dataIndex;
                                if (dataset && Array.isArray(dataset.originalData)) {
                                    const value = dataset.originalData[dataIndex];
                                    if (value == null) {
                                        return `${dataset.label}: n/a`;
                                    }
                                    return `${dataset.label}: ${value} ms`;
                                }
                                return `${context.dataset.label}: ${context.formattedValue}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        ticks: {
                            color: theme.textSubtle,
                            display: true,
                            maxRotation: 45,
                            minRotation: 0
                        },
                        grid: { color: theme.grid }
                    },
                    y: {
                        min: 0,
                        max: maxDelayValue <= lowBandMax ? undefined : scaledAxisMax,
                        ticks: {
                            color: theme.textSubtle,
                            callback: (value) => `${inverseScale(value)} ms`
                        },
                        grid: { color: theme.grid }
                    }
                }
            }
        });

        if (referenceToggle) {
            referenceToggle.addEventListener('change', (event) => {
                showReferences = event.target.checked;
                chartInstance.data.datasets.forEach((dataset) => {
                    if (dataset.referenceLine) {
                        dataset.hidden = !showReferences;
                    }
                });
                chartInstance.update();
            });
        }

        if (boundsToggle) {
            boundsToggle.addEventListener('change', (event) => {
                showBounds = event.target.checked;
                chartInstance.data.datasets.forEach((dataset) => {
                    if (dataset.bandLine) {
                        dataset.hidden = !showBounds;
                    }
                });
                chartInstance.update();
            });
        }
    }

    const samplesBody = document.getElementById('samplesBody');
    const pagination = document.getElementById('pagination');
    const pageInfo = document.getElementById('pageInfo');

    const renderPage = (page) => {
        if (!samplesBody) {
            return;
        }
        const safePage = Math.min(Math.max(page, 1), totalPages);
        const start = (safePage - 1) * pageSize;
        const end = Math.min(start + pageSize, samples.length);
        samplesBody.innerHTML = '';
        for (let i = start; i < end; i += 1) {
            const s = samples[i];

            // Build block display with finalized tag if applicable
            let blockDisplay = s.blockNumber ? String(s.blockNumber) : '-';
            if (s.blockNumber && s.finalized) {
                blockDisplay += ' <span class="tag tag-finalized">finalized</span>';
            }

            // Build source display with multiple tags if applicable
            let sourceDisplay = '';
            if (s.sources && Array.isArray(s.sources)) {
                sourceDisplay = s.sources.map(src => {
                    if (src === 'WS') {
                        return '<span class="tag tag-ws">WS</span>';
                    } else if (src === 'HTTP') {
                        return '<span class="tag tag-http">HTTP</span>';
                    }
                    return '';
                }).join(' ');
            }

            const row = document.createElement('tr');
            row.innerHTML = `
            <td>${s.time ?? '-'}</td>
            <td>${sourceDisplay || '-'}</td>
            <td>${s.status ?? '-'}</td>
            <td>${s.latencyMs !== null && s.latencyMs !== undefined ? s.latencyMs + ' ms' : 'n/a'}</td>
            <td>${blockDisplay}</td>
            <td>${s.transactionCount ?? '-'}</td>
            <td>${s.gasPriceWei ? (s.gasPriceWei / 1_000_000_000).toFixed(4) : '-'}</td>
        `;
            samplesBody.appendChild(row);
        }
        if (pageInfo) {
            pageInfo.textContent = `Showing page ${safePage} of ${totalPages}`;
        }
        if (pagination) {
            Array.from(pagination.children).forEach((child, index) => {
                child.classList.toggle('active', index + 1 === safePage);
            });
        }
    };

    if (pagination) {
        pagination.innerHTML = '';
        for (let p = 1; p <= totalPages; p += 1) {
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = String(p);
            link.addEventListener('click', (event) => {
                event.preventDefault();
                renderPage(p);
            });
            pagination.appendChild(link);
        }
    }

    renderPage(1);

    const anomaliesBody = document.getElementById('anomaliesBody');
    const anomaliesPagination = document.getElementById('anomaliesPagination');
    const anomalyPageInfo = document.getElementById('anomalyPageInfo');

    const renderAnomalies = (page) => {
        if (!anomaliesBody) {
            return;
        }
        const safePage = Math.min(Math.max(page, 1), anomalyTotalPages);
        const start = (safePage - 1) * anomalyPageSize;
        const end = Math.min(start + anomalyPageSize, anomalies.length);
        anomaliesBody.innerHTML = '';
        for (let i = start; i < end; i += 1) {
            const a = anomalies[i];
            const row = document.createElement('tr');

            let messageContent = a.message ?? '-';
            if (a.count > 1) {
                messageContent += ` <span class="count-badge">${a.count}</span>`;
            }

            row.innerHTML = `
            <td>${a.time ?? '-'}</td>
            <td>${a.type ?? '-'}</td>
            <td>${a.source ?? '-'}</td>
            <td>${messageContent}</td>
            <td><button class="button ghost anomaly-link" data-id="${a.id}">Open</button></td>
        `;
            anomaliesBody.appendChild(row);
        }
        if (anomalyPageInfo) {
            anomalyPageInfo.textContent = `Showing page ${safePage} of ${anomalyTotalPages}`;
        }
        if (anomaliesPagination) {
            Array.from(anomaliesPagination.children).forEach((child, index) => {
                child.classList.toggle('active', index + 1 === safePage);
            });
        }
    };

    if (anomaliesPagination) {
        anomaliesPagination.innerHTML = '';
        for (let p = 1; p <= anomalyTotalPages; p += 1) {
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = String(p);
            link.addEventListener('click', (event) => {
                event.preventDefault();
                renderAnomalies(p);
            });
            anomaliesPagination.appendChild(link);
        }
    }

    renderAnomalies(1);
</script>

<script>
    const toggleButton = document.getElementById('toggleSamples');
    const samplesPanel = document.getElementById('samplesPanel');
    if (toggleButton && samplesPanel) {
        toggleButton.addEventListener('click', () => {
            const collapsed = samplesPanel.classList.toggle('collapsed');
            toggleButton.textContent = collapsed ? 'Show samples' : 'Hide samples';
        });
    }

    const toggleAnomalies = document.getElementById('toggleAnomalies');
    const anomaliesPanel = document.getElementById('anomaliesPanel');
    if (toggleAnomalies && anomaliesPanel) {
        toggleAnomalies.addEventListener('click', () => {
            const collapsed = anomaliesPanel.classList.toggle('collapsed');
            toggleAnomalies.textContent = collapsed ? 'Show anomalies' : 'Hide anomalies';
        });
    }

    const nodeSelect = document.getElementById('nodeSelect');
    if (nodeSelect) {
        nodeSelect.addEventListener('change', () => {
            const selected = nodeSelect.value;
            const url = new URL(window.location.href);
            url.searchParams.set('node', selected);
            if (!url.searchParams.get('range')) {
                url.searchParams.set('range', '2h');
            }
            window.location.href = url.toString();
        });
    }

    const anomalyModal = document.getElementById('anomalyModal');
    const anomalyContent = document.getElementById('anomalyContent');
    const closeAnomaly = document.getElementById('closeAnomaly');
    const openModal = () => {
        if (anomalyModal) {
            anomalyModal.classList.remove('hidden');
            anomalyModal.setAttribute('aria-hidden', 'false');
        }
    };
    const closeModal = () => {
        if (anomalyModal) {
            anomalyModal.classList.add('hidden');
            anomalyModal.setAttribute('aria-hidden', 'true');
        }
    };
    if (closeAnomaly) {
        closeAnomaly.addEventListener('click', closeModal);
    }
    if (anomalyModal) {
        const backdrop = anomalyModal.querySelector('.modal-backdrop');
        if (backdrop) {
            backdrop.addEventListener('click', closeModal);
        }
    }

    const openAnomaly = async (id) => {
        if (!id || !anomalyContent) {
            return;
        }
        anomalyContent.innerHTML = '<p class="muted">Loading...</p>';
        openModal();
        try {
            const response = await fetch(`/api/anomalies/${id}`);
            if (!response.ok) {
                anomalyContent.innerHTML = '<p class="muted">Unable to load anomaly details.</p>';
                return;
            }
            const data = await response.json();
            const timeText = data.timestamp ? new Date(data.timestamp).toLocaleString() : '-';
            const formatHash = (hash) => {
                if (!hash || hash.length < 15) return hash || '-';
                return hash.substring(0, 6) + '...' + hash.substring(hash.length - 6);
            };
            const copyBtn = (text) => {
                if (!text) return '';
                return `<button class="copy-btn" onclick="copyToClipboard('${text}')" title="Copy full hash">ðŸ“‹</button>`;
            };

            anomalyContent.innerHTML = `
            <div class="detail-grid">
                <div><span class="label">ID</span><span>${data.id ?? '-'}</span></div>
                <div><span class="label">Node</span><span>${data.nodeName ?? '-'}</span></div>
                <div><span class="label">Time</span><span>${timeText}</span></div>
                <div><span class="label">Type</span><span>${data.type ?? '-'}</span></div>
                <div><span class="label">Source</span><span>${data.source ?? '-'}</span></div>
                <div><span class="label">Block</span><span>${data.blockNumber ?? '-'}</span></div>
                <div><span class="label">Block Hash</span><span class="hash-container">${formatHash(data.blockHash)} ${copyBtn(data.blockHash)}</span></div>
                <div><span class="label">Parent Hash</span><span class="hash-container">${formatHash(data.parentHash)} ${copyBtn(data.parentHash)}</span></div>
                <div><span class="label">Message</span><span>${data.message ?? '-'}</span></div>
            </div>
            <div class="detail-block">
                <span class="label">Details</span>
                <pre>${data.details ?? '-'}</pre>
            </div>
        `;
        } catch (error) {
            anomalyContent.innerHTML = '<p class="muted">Unable to load anomaly details.</p>';
        }
    };

    window.copyToClipboard = (text) => {
        if (!text) return;
        navigator.clipboard.writeText(text).then(() => {
            // Optional: Show visual feedback
        }).catch(err => {
            console.error('Failed to copy text: ', err);
        });
    };

    const anomaliesBodyEl = document.getElementById('anomaliesBody');
    if (anomaliesBodyEl) {
        anomaliesBodyEl.addEventListener('click', (event) => {
            const target = event.target;
            if (target && target.classList && target.classList.contains('anomaly-link')) {
                event.preventDefault();
                openAnomaly(target.getAttribute('data-id'));
            }
        });
    }
</script>
</th:block>

<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChainCheck Dashboard</title>
    <link rel="icon" type="image/svg+xml" th:href="@{/favicon.svg}" />
    <link rel="stylesheet" th:href="@{/style.css}" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@4.1.0/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>

<body>
    <header class="app-header">
        <div>
            <p class="title">ChainCheck<span th:if="${appTitle != null and !appTitle.isEmpty()}"
                    th:text="' Â· ' + ${appTitle}"
                    th:style="'font-weight: bold; color: ' + ${appTitleColor} + ';'"></span></p>
        </div>
        <div class="header-controls">
            <label class="select-label">
                Node:
                <select id="nodeSelect">
                    <option th:each="node : ${nodes}" th:value="${node.key}" th:selected="${node.key} == ${nodeKey}"
                        th:text="${node.name}"></option>
                </select>
            </label>
            <div class="range-selector">
                <span>Range:</span>
                <a th:each="r : ${ranges}" th:href="@{/dashboard(range=${r.key}, node=${nodeKey})}" th:text="${r.key}"
                    th:classappend="${r} == ${range} ? 'active' : ''">
                </a>
            </div>
        </div>
    </header>

    <section class="summary-grid">
        <div class="card">
            <h3>Samples &amp; Errors</h3>
            <div>
                <span class="muted">HTTP:</span>
                <span th:text="${view.summary.httpSamples}">0</span>
                <span class="muted">WS:</span>
                <span th:text="${view.summary.wsSamples}">0</span>
            </div>
            <div>
                <span class="muted">Errors:</span>
                <span th:text="${view.summary.errorCount}">0</span>
            </div>
            <div>
                <span class="muted">Uptime</span>
                <span th:text="${#numbers.formatDecimal(view.summary.uptimePercent, 1, 1)}">0</span>
                <span class="muted">%</span>
            </div>
        </div>
        <div class="card">
            <h3>Anomalies</h3>
            <div>
                <span class="muted">Delay:</span>
                <span th:text="${view.summary.delayCount}">0</span>
            </div>
            <div>
                <span class="muted">Reorg:</span>
                <span th:text="${view.summary.reorgCount}">0</span>
            </div>
            <div>
                <span class="muted">Block Gap:</span>
                <span th:text="${view.summary.blockGapCount}">0</span>
            </div>
            <div>
                <span class="muted">Stale Blocks:</span>
                <span th:text="${view.summary.staleBlockCount}">0</span>
            </div>
        </div>
        <div class="card">
            <h3>Network Latency</h3>
            <div>
                <span class="muted">Avg</span>
                <span th:text="${#numbers.formatDecimal(view.summary.avgLatencyMs, 1, 2)}">0</span>
                <span class="muted">ms</span>
            </div>
            <div>
                <span class="muted">P95</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p95LatencyMs, 1, 2)}">0</span>
                <span class="muted">ms</span>
            </div>
            <div>
                <span class="muted">P99</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p99LatencyMs, 1, 2)}">0</span>
                <span class="muted">ms</span>
            </div>
        </div>
        <div class="card" th:if="${view.wsConfigured}">
            <h3>New Blocks</h3>
            <div>
                <span class="muted">Avg</span>
                <span th:text="${#numbers.formatDecimal(view.summary.avgNewBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
            <div>
                <span class="muted">P95</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p95NewBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
            <div>
                <span class="muted">P99</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p99NewBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
        </div>
        <div class="card" th:if="${view.safeBlocksEnabled}">
            <h3>Safe Blocks</h3>
            <div>
                <span class="muted">Avg</span>
                <span th:text="${#numbers.formatDecimal(view.summary.avgSafeBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
            <div>
                <span class="muted">P95</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p95SafeBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
            <div>
                <span class="muted">P99</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p99SafeBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
        </div>
        <div class="card" th:if="${view.httpConfigured}">
            <h3>Finalized Blocks</h3>
            <div>
                <span class="muted">Avg</span>
                <span th:text="${#numbers.formatDecimal(view.summary.avgFinalizedBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
            <div>
                <span class="muted">P95</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p95FinalizedBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
            <div>
                <span class="muted">P99</span>
                <span th:text="${#numbers.formatDecimal(view.summary.p99FinalizedBlockPropagationMs / 1000, 1, 2)}">0</span>
                <span class="muted">s</span>
            </div>
        </div>
    </section>

    <section class="panel">
        <h2>RPC Status</h2>
        <div class="status-grid">
            <div class="status-item">
                <span class="status-light"
                    th:classappend="${view.httpConfigured} ? (${view.httpUp} ? ' status-http-up' : ' status-error') : ' status-off'"></span>
                <span>HTTP RPC</span>
            </div>
            <div class="status-item">
                <span class="status-light"
                    th:classappend="${view.wsConfigured} ? (${view.wsUp} ? ' status-ws-up' : ' status-error') : ' status-off'"></span>
                <span>WebSocket RPC</span>
            </div>
            <div class="status-item">
                <span class="label">Latest Block</span>
                <span th:text="${view.latestBlockNumber != null ? view.latestBlockNumber : '-'}">-</span>
            </div>
        </div>
        <div class="rpc-columns">
            <div class="rpc-column">
                <h3>HTTP</h3>
                <div class="rpc-item">
                    <span class="label">HTTP Connected</span>
                    <span
                        th:text="${view.httpStatus.connectedSince != null ? #temporals.format(view.httpStatus.connectedSince, 'yyyy-MM-dd HH:mm:ss') : '-'}">-</span>
                </div>
                <div class="rpc-item">
                    <span class="label">Last Error</span>
                    <span th:text="${view.httpStatus.lastError != null ? view.httpStatus.lastError : '-'}">-</span>
                </div>
            </div>
            <div class="rpc-column">
                <h3>WebSocket</h3>
                <div class="rpc-item">
                    <span class="label">WS Connected</span>
                    <span
                        th:text="${view.wsStatus.connectedSince != null ? #temporals.format(view.wsStatus.connectedSince, 'yyyy-MM-dd HH:mm:ss') : '-'}">-</span>
                </div>
                <div class="rpc-item">
                    <span class="label">Last Error</span>
                    <span th:text="${view.wsStatus.lastError != null ? view.wsStatus.lastError : '-'}">-</span>
                </div>
            </div>
        </div>
    </section>

    <div id="anomalyModal" class="modal hidden" aria-hidden="true">
        <div class="modal-backdrop"></div>
        <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="anomalyTitle">
            <div class="modal-header">
                <h2 id="anomalyTitle">Anomaly Details</h2>
                <button type="button" class="button ghost" id="closeAnomaly">Close</button>
            </div>
            <div id="anomalyContent" class="modal-content">
                <p class="muted">Loading...</p>
            </div>
        </div>
    </div>

    <section class="panel">
        <h2>Network Latency &amp; Block Propagation</h2>
        <canvas id="latencyChart" height="120"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <h2>Anomalies <span class="count-badge" th:text="${view.totalAnomalies}">0</span></h2>
            <button id="toggleAnomalies" class="button ghost" type="button">Show anomalies</button>
        </div>
        <div id="anomaliesPanel" class="collapsed">
            <p class="muted">
                <span id="anomalyPageInfo">Showing page 1 of 1</span>
                Â· Total anomalies (max 1000): <span th:text="${view.totalAnomalies}">0</span>
            </p>
            <div id="anomalyEmpty" class="empty" th:if="${#lists.isEmpty(view.anomalies)}">No anomalies in this range.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Type</th>
                        <th>Source</th>
                        <th>Message</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody id="anomaliesBody"></tbody>
            </table>
            <div class="pagination" id="anomaliesPagination"></div>
        </div>
    </section>

    <section class="panel">
        <div class="panel-header">
            <h2>Samples <span class="count-badge" th:text="${view.totalSamples}">0</span></h2>
            <button id="toggleSamples" class="button ghost" type="button">Show samples</button>
        </div>
        <div id="samplesPanel" class="collapsed">
            <p class="muted">
                <span id="pageInfo">Showing page 1 of 1</span>
                Â· Total samples (max 1000): <span th:text="${view.totalSamples}">0</span>
            </p>
            <table>
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Source</th>
                        <th>Status</th>
                        <th>Latency</th>
                        <th>Block</th>
                        <th>Transactions</th>
                        <th>Gas Price (gwei)</th>
                    </tr>
                </thead>
                <tbody id="samplesBody"></tbody>
            </table>
            <div class="pagination" id="pagination"></div>
        </div>
    </section>

    <script th:inline="javascript">
        const timestamps = /*[[${view.chartTimestamps}]]*/[];
        const labels = /*[[${view.chartLabels}]]*/[];
        const latencyData = /*[[${view.chartLatencies}]]*/[];
        const errorRateData = /*[[${view.chartErrorRates}]]*/[];
        const wsErrorRateData = /*[[${view.chartWsErrorRates}]]*/[];
        const headDelayData = /*[[${view.chartHeadDelays}]]*/[];
        const safeDelayData = /*[[${view.chartSafeDelays}]]*/[];
        const finalizedDelayData = /*[[${view.chartFinalizedDelays}]]*/[];
        const wsConfigured = /*[[${view.wsConfigured}]]*/ false;
        const safeBlocksEnabled = /*[[${view.safeBlocksEnabled}]]*/ false;
        const samples = /*[[${view.sampleRows}]]*/[];
        const anomalies = /*[[${view.anomalyRows}]]*/[];
        const pageSize = /*[[${view.pageSize}]]*/ 50;
        const totalPages = /*[[${view.totalPages}]]*/ 1;
        const anomalyPageSize = /*[[${view.anomalyPageSize}]]*/ 50;
        const anomalyTotalPages = /*[[${view.anomalyTotalPages}]]*/ 1;

        const maxDelayValue = Math.max(
            0,
            ...latencyData.filter(value => value != null),
            ...headDelayData.filter(value => value != null),
            ...safeDelayData.filter(value => value != null),
            ...finalizedDelayData.filter(value => value != null)
        );
        const scaledAxisMax = 1000;
        const lowBandRatio = 0.2;
        const lowBandMax = 500;
        const lowBandSize = scaledAxisMax * lowBandRatio;

        const scaleValue = (value) => {
            if (value == null) {
                return null;
            }
            if (maxDelayValue <= lowBandMax) {
                return value;
            }
            if (value <= lowBandMax) {
                return (value / lowBandMax) * lowBandSize;
            }
            return lowBandSize + ((value - lowBandMax) / (maxDelayValue - lowBandMax)) * (scaledAxisMax - lowBandSize);
        };

        const inverseScale = (value) => {
            if (maxDelayValue <= lowBandMax) {
                return value;
            }
            if (value <= lowBandSize) {
                return Math.round((value / lowBandSize) * lowBandMax);
            }
            return Math.round(lowBandMax + ((value - lowBandSize) / (scaledAxisMax - lowBandSize)) * (maxDelayValue - lowBandMax));
        };

        const latencyScaled = latencyData.map(scaleValue);
        const headDelayScaled = headDelayData.map(scaleValue);
        const safeDelayScaled = safeDelayData.map(scaleValue);
        const finalizedDelayScaled = finalizedDelayData.map(scaleValue);

        const ctx = document.getElementById('latencyChart');
        if (ctx) {
            const datasets = [{
                label: 'Network Latency',
                data: latencyScaled,
                originalData: latencyData,
                borderColor: '#2b4cff',
                backgroundColor: 'rgba(43, 76, 255, 0.2)',
                spanGaps: true,
                tension: 0.2,
                yAxisID: 'y'
            }];

            const errorBarPlugin = {
                id: 'errorBars',
                beforeDatasetsDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    const xScale = scales.x;
                    if (!chartArea || !xScale || !timestamps || timestamps.length === 0) {
                        return;
                    }

                    const minWidthPx = 5;
                    const height = chartArea.bottom - chartArea.top;

                    const getStepWidth = (index) => {
                        if (index < timestamps.length - 1) {
                            return xScale.getPixelForValue(index + 1) - xScale.getPixelForValue(index);
                        }
                        if (index > 0) {
                            return xScale.getPixelForValue(index) - xScale.getPixelForValue(index - 1);
                        }
                        return minWidthPx;
                    };

                    const drawBars = (series, color) => {
                        let startIndex = null;
                        for (let i = 0; i <= series.length; i += 1) {
                            const hasError = i < series.length && series[i] != null && series[i] > 0;
                            if (hasError && startIndex === null) {
                                startIndex = i;
                            }
                            if (startIndex !== null && (!hasError || i === series.length)) {
                                const endIndex = i - 1;
                                const xStart = xScale.getPixelForValue(startIndex);
                                const xEnd = xScale.getPixelForValue(endIndex) + getStepWidth(endIndex);
                                const width = Math.max(minWidthPx, xEnd - xStart);
                                ctx.fillStyle = color;
                                ctx.fillRect(xStart, chartArea.top, width, height);
                                startIndex = null;
                            }
                        }
                    };

                    ctx.save();
                    drawBars(errorRateData, 'rgba(255, 92, 92, 0.25)');
                    if (wsConfigured) {
                        drawBars(wsErrorRateData, 'rgba(168, 85, 247, 0.25)');
                    }
                    ctx.restore();
                }
            };

            const scaleIndicatorPlugin = {
                id: 'scaleIndicator',
                afterDatasetsDraw(chart) {
                    if (maxDelayValue <= lowBandMax) {
                        return;
                    }
                    const { ctx, chartArea, scales } = chart;
                    const yScale = scales.y;
                    if (!chartArea || !yScale) {
                        return;
                    }
                    const boundaryValue = lowBandSize;
                    const y = yScale.getPixelForValue(boundaryValue);
                    const isLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
                    const lineColor = isLight ? 'rgba(43, 76, 255, 0.35)' : 'rgba(138, 162, 255, 0.45)';
                    const labelColor = isLight ? '#1a1a1a' : '#e6e8ee';
                    const badgeBg = isLight ? 'rgba(43, 76, 255, 0.12)' : 'rgba(138, 162, 255, 0.18)';

                    ctx.save();
                    ctx.setLineDash([6, 6]);
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = lineColor;
                    ctx.beginPath();
                    ctx.moveTo(chartArea.left, y);
                    ctx.lineTo(chartArea.right, y);
                    ctx.stroke();

                    const label = `Scale change @ ${lowBandMax} ms`;
                    ctx.font = '12px "Inter", "Segoe UI", system-ui, sans-serif';
                    const textWidth = ctx.measureText(label).width;
                    const paddingX = 8;
                    const paddingY = 4;
                    const badgeWidth = textWidth + paddingX * 2;
                    const badgeHeight = 20;
                    const badgeX = chartArea.right - badgeWidth - 8;
                    const badgeY = Math.max(chartArea.top + 6, y - badgeHeight - 6);

                    ctx.setLineDash([]);
                    ctx.fillStyle = badgeBg;
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, 6);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = labelColor;
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, badgeX + paddingX, badgeY + badgeHeight / 2);
                    ctx.restore();
                }
            };

            if (wsConfigured) {
                datasets.push({
                    label: 'Head Delay',
                    data: headDelayScaled,
                    originalData: headDelayData,
                    borderColor: '#f59e0b',
                    backgroundColor: 'rgba(245, 158, 11, 0.2)',
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y'
                });

                if (safeBlocksEnabled) {
                    datasets.push({
                        label: 'Safe Delay',
                        data: safeDelayScaled,
                        originalData: safeDelayData,
                        borderColor: '#eab308',
                        backgroundColor: 'rgba(234, 179, 8, 0.2)',
                        spanGaps: true,
                        tension: 0.2,
                        yAxisID: 'y'
                    });
                }

                datasets.push({
                    label: 'Finalized Delay',
                    data: finalizedDelayScaled,
                    originalData: finalizedDelayData,
                    borderColor: '#22c55e',
                    backgroundColor: 'rgba(34, 197, 94, 0.2)',
                    spanGaps: true,
                    tension: 0.2,
                    yAxisID: 'y'
                });
            }

            datasets.push({
                label: 'HTTP Errors',
                data: labels.map(() => null),
                borderColor: 'rgba(255, 92, 92, 0.25)',
                backgroundColor: 'rgba(255, 92, 92, 0.25)',
                pointRadius: 0,
                borderWidth: 0,
                showLine: false
            });

            if (wsConfigured) {
                datasets.push({
                    label: 'WS Errors',
                    data: labels.map(() => null),
                    borderColor: 'rgba(168, 85, 247, 0.25)',
                    backgroundColor: 'rgba(168, 85, 247, 0.25)',
                    pointRadius: 0,
                    borderWidth: 0,
                    showLine: false
                });
            }

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets
                },
                plugins: [errorBarPlugin, scaleIndicatorPlugin],
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const dataset = context.dataset;
                                    const dataIndex = context.dataIndex;
                                    if (dataset && Array.isArray(dataset.originalData)) {
                                        const value = dataset.originalData[dataIndex];
                                        if (value == null) {
                                            return `${dataset.label}: n/a`;
                                        }
                                        return `${dataset.label}: ${value} ms`;
                                    }
                                    return `${context.dataset.label}: ${context.formattedValue}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            ticks: {
                                color: '#8b93a7',
                                display: true,
                                maxRotation: 45,
                                minRotation: 0
                            },
                            grid: { color: '#20263a' }
                        },
                        y: {
                            min: 0,
                            max: maxDelayValue <= lowBandMax ? undefined : scaledAxisMax,
                            ticks: {
                                color: '#8b93a7',
                                callback: (value) => `${inverseScale(value)} ms`
                            },
                            grid: { color: '#20263a' }
                        }
                    }
                }
            });
        }

        const samplesBody = document.getElementById('samplesBody');
        const pagination = document.getElementById('pagination');
        const pageInfo = document.getElementById('pageInfo');

        const renderPage = (page) => {
            if (!samplesBody) {
                return;
            }
            const safePage = Math.min(Math.max(page, 1), totalPages);
            const start = (safePage - 1) * pageSize;
            const end = Math.min(start + pageSize, samples.length);
            samplesBody.innerHTML = '';
            for (let i = start; i < end; i += 1) {
                const s = samples[i];

                // Build block display with finalized tag if applicable
                let blockDisplay = s.blockNumber ? String(s.blockNumber) : '-';
                if (s.blockNumber && s.finalized) {
                    blockDisplay += ' <span class="tag tag-finalized">finalized</span>';
                }

                // Build source display with multiple tags if applicable
                let sourceDisplay = '';
                if (s.sources && Array.isArray(s.sources)) {
                    sourceDisplay = s.sources.map(src => {
                        if (src === 'WS') {
                            return '<span class="tag tag-ws">WS</span>';
                        } else if (src === 'HTTP') {
                            return '<span class="tag tag-http">HTTP</span>';
                        }
                        return '';
                    }).join(' ');
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                <td>${s.time ?? '-'}</td>
                <td>${sourceDisplay || '-'}</td>
                <td>${s.status ?? '-'}</td>
                <td>${s.latencyMs !== null && s.latencyMs !== undefined ? s.latencyMs + ' ms' : 'n/a'}</td>
                <td>${blockDisplay}</td>
                <td>${s.transactionCount ?? '-'}</td>
                <td>${s.gasPriceWei ? (s.gasPriceWei / 1_000_000_000).toFixed(4) : '-'}</td>
            `;
                samplesBody.appendChild(row);
            }
            if (pageInfo) {
                pageInfo.textContent = `Showing page ${safePage} of ${totalPages}`;
            }
            if (pagination) {
                Array.from(pagination.children).forEach((child, index) => {
                    child.classList.toggle('active', index + 1 === safePage);
                });
            }
        };

        if (pagination) {
            pagination.innerHTML = '';
            for (let p = 1; p <= totalPages; p += 1) {
                const link = document.createElement('a');
                link.href = '#';
                link.textContent = String(p);
                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    renderPage(p);
                });
                pagination.appendChild(link);
            }
        }

        renderPage(1);

        const anomaliesBody = document.getElementById('anomaliesBody');
        const anomaliesPagination = document.getElementById('anomaliesPagination');
        const anomalyPageInfo = document.getElementById('anomalyPageInfo');

        const renderAnomalies = (page) => {
            if (!anomaliesBody) {
                return;
            }
            const safePage = Math.min(Math.max(page, 1), anomalyTotalPages);
            const start = (safePage - 1) * anomalyPageSize;
            const end = Math.min(start + anomalyPageSize, anomalies.length);
            anomaliesBody.innerHTML = '';
            for (let i = start; i < end; i += 1) {
                const a = anomalies[i];
                const row = document.createElement('tr');

                let messageContent = a.message ?? '-';
                if (a.count > 1) {
                    messageContent += ` <span class="count-badge">${a.count}</span>`;
                }

                row.innerHTML = `
                <td>${a.time ?? '-'}</td>
                <td>${a.type ?? '-'}</td>
                <td>${a.source ?? '-'}</td>
                <td>${messageContent}</td>
                <td><button class="button ghost anomaly-link" data-id="${a.id}">Open</button></td>
            `;
                anomaliesBody.appendChild(row);
            }
            if (anomalyPageInfo) {
                anomalyPageInfo.textContent = `Showing page ${safePage} of ${anomalyTotalPages}`;
            }
            if (anomaliesPagination) {
                Array.from(anomaliesPagination.children).forEach((child, index) => {
                    child.classList.toggle('active', index + 1 === safePage);
                });
            }
        };

        if (anomaliesPagination) {
            anomaliesPagination.innerHTML = '';
            for (let p = 1; p <= anomalyTotalPages; p += 1) {
                const link = document.createElement('a');
                link.href = '#';
                link.textContent = String(p);
                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    renderAnomalies(p);
                });
                anomaliesPagination.appendChild(link);
            }
        }

        renderAnomalies(1);
    </script>

    <script>
        const toggleButton = document.getElementById('toggleSamples');
        const samplesPanel = document.getElementById('samplesPanel');
        if (toggleButton && samplesPanel) {
            toggleButton.addEventListener('click', () => {
                const collapsed = samplesPanel.classList.toggle('collapsed');
                toggleButton.textContent = collapsed ? 'Show samples' : 'Hide samples';
            });
        }

        const toggleAnomalies = document.getElementById('toggleAnomalies');
        const anomaliesPanel = document.getElementById('anomaliesPanel');
        if (toggleAnomalies && anomaliesPanel) {
            toggleAnomalies.addEventListener('click', () => {
                const collapsed = anomaliesPanel.classList.toggle('collapsed');
                toggleAnomalies.textContent = collapsed ? 'Show anomalies' : 'Hide anomalies';
            });
        }

        const nodeSelect = document.getElementById('nodeSelect');
        if (nodeSelect) {
            nodeSelect.addEventListener('change', () => {
                const selected = nodeSelect.value;
                const url = new URL(window.location.href);
                url.searchParams.set('node', selected);
                if (!url.searchParams.get('range')) {
                    url.searchParams.set('range', '2h');
                }
                window.location.href = url.toString();
            });
        }

        const anomalyModal = document.getElementById('anomalyModal');
        const anomalyContent = document.getElementById('anomalyContent');
        const closeAnomaly = document.getElementById('closeAnomaly');
        const openModal = () => {
            if (anomalyModal) {
                anomalyModal.classList.remove('hidden');
                anomalyModal.setAttribute('aria-hidden', 'false');
            }
        };
        const closeModal = () => {
            if (anomalyModal) {
                anomalyModal.classList.add('hidden');
                anomalyModal.setAttribute('aria-hidden', 'true');
            }
        };
        if (closeAnomaly) {
            closeAnomaly.addEventListener('click', closeModal);
        }
        if (anomalyModal) {
            const backdrop = anomalyModal.querySelector('.modal-backdrop');
            if (backdrop) {
                backdrop.addEventListener('click', closeModal);
            }
        }

        const openAnomaly = async (id) => {
            if (!id || !anomalyContent) {
                return;
            }
            anomalyContent.innerHTML = '<p class="muted">Loading...</p>';
            openModal();
            try {
                const response = await fetch(`/api/anomalies/${id}`);
                if (!response.ok) {
                    anomalyContent.innerHTML = '<p class="muted">Unable to load anomaly details.</p>';
                    return;
                }
                const data = await response.json();
                const timeText = data.timestamp ? new Date(data.timestamp).toLocaleString() : '-';
                const formatHash = (hash) => {
                    if (!hash || hash.length < 15) return hash || '-';
                    return hash.substring(0, 6) + '...' + hash.substring(hash.length - 6);
                };
                const copyBtn = (text) => {
                    if (!text) return '';
                    return `<button class="copy-btn" onclick="copyToClipboard('${text}')" title="Copy full hash">ðŸ“‹</button>`;
                };

                anomalyContent.innerHTML = `
                <div class="detail-grid">
                    <div><span class="label">ID</span><span>${data.id ?? '-'}</span></div>
                    <div><span class="label">Node</span><span>${data.nodeName ?? '-'}</span></div>
                    <div><span class="label">Time</span><span>${timeText}</span></div>
                    <div><span class="label">Type</span><span>${data.type ?? '-'}</span></div>
                    <div><span class="label">Source</span><span>${data.source ?? '-'}</span></div>
                    <div><span class="label">Block</span><span>${data.blockNumber ?? '-'}</span></div>
                    <div><span class="label">Block Hash</span><span class="hash-container">${formatHash(data.blockHash)} ${copyBtn(data.blockHash)}</span></div>
                    <div><span class="label">Parent Hash</span><span class="hash-container">${formatHash(data.parentHash)} ${copyBtn(data.parentHash)}</span></div>
                    <div><span class="label">Message</span><span>${data.message ?? '-'}</span></div>
                </div>
                <div class="detail-block">
                    <span class="label">Details</span>
                    <pre>${data.details ?? '-'}</pre>
                </div>
            `;
            } catch (error) {
                anomalyContent.innerHTML = '<p class="muted">Unable to load anomaly details.</p>';
            }
        };

        window.copyToClipboard = (text) => {
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                // Optional: Show visual feedback
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        };

        const anomaliesBodyEl = document.getElementById('anomaliesBody');
        if (anomaliesBodyEl) {
            anomaliesBodyEl.addEventListener('click', (event) => {
                const target = event.target;
                if (target && target.classList && target.classList.contains('anomaly-link')) {
                    event.preventDefault();
                    openAnomaly(target.getAttribute('data-id'));
                }
            });
        }
    </script>
</body>

</html>